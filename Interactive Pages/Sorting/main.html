<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Sortering Algoritmer</title>
    <link rel="stylesheet" href="../prism.css">
    <link rel="stylesheet" href="../codedisplay.css">
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="../pages.css">
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(','\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
</head>
<body>
    <div class="insert-code" id="Sorting/main"></div>
    <div class="insert-code" id="Sorting/bubblesort"></div>
    <div class="insert-code" id="Sorting/insertionsort"></div>

    <div id="container">
        <div class="page">
            <h1>Sortering Algoritmer</h1>
            <h2>Forord</h2>
            <p>
                Alle programmer er skrevet af mig, Noah Dirksen, og kan findes på min <a href="https://github.com/Noddy05/noddy05.github.io">GitHub</a>.
                Alt tekst er skrevet af mig og alle matematiske udledninger er lavet af mig. <br>
                Denne artikel opdaterer automatisk og alt udvalgt kode bliver hentet fra min GitHub når hjemmesiden åbnes. Den nedenstående indholdsfortegnelse er
                auto genereret og alt udvalgt kode kan udvides på "View source..."-knappen. Så kan man se hele scriptet.<br>
                Du skal være velkommen til at lege rundt med de forskellige algortimer og se hvordan de adskiller sig fra hinanden.
                <br>
                Originalt skrev jeg hjemmesiden på engelsk, men er i gang med at omskrive det hele til dansk, så hver klar på begge dele.
            </p>
            <ul id="table-of-contents"></ul>
        </div>
        <div class="page">
            <h2>Opstilling</h2>
            <h3>At tegne et array</h3>
            <p>
                Sammenligning af forskellige sorteringsalgoritmer er en klassiker og en must-have. Sorteringsalgoritmer er meget simple, men gennem denne artikel ses det hvordan dybere forståelse for algoritmiske paradigmer som ”divide-and-conquer” metoden kan lede til en optimeret sorteringsalgoritme. 
                <br>
                Opstillingen behøvet for at tegne et lærred i JS er en længere proces
                - for overskuelighedens skyld, hvis du kun er interesseret i algoritmerne, er dette minimeret, men man kan læse mere ved at trykke på plusset
                <div class="derivation">
                    <input type="checkbox" name="derivation" id="opstilling">
                    <label for="opstilling">Opstilling</label>
                    <div class="content">
                        Før vi kan fremvise sorteringsalgoritmer, skal vi finde en måde at vise et array for brugeren. Dette skal give en visuel forståelse for algoritmen og hvordan hver algoritme adskiller sig fra andre.
                        I HTML har jeg defineret et ’canvas’ (på dansk: lærred) som kan tegnes på, for at begynde at tegne skal vi oprette en reference til dette lærred i JavaScript:
                        <div class="code-snippet 16 18" id="Sorting/main"></div>
                        <!-- <kode>-->
                        Nu hvor vi har en reference til lærredet kan vi begynde at tegne på det. Vi opretter en funktion som tager et array og tegner det på skærmen. Det giver mening at bryde denne funktion op i to funktioner; den første kalder vi drawElement og drawArray. 
                        <pre><code class='language-js'>function drawElement(){ }
function drawArray(){ }</code></pre>
                        <!-- <falsk kode bare hvis drawElement som en tom funktion samt drawArray>-->
                        Men i stedet for at give den et array, et canvas og en context, så lad os samle det i et objekt vi kalder sortingObject:
                        <pre><code class='language-js'>const sortingObject = {
    //Til at tegne array'et:
    ctx: null,
    //For at oprette og sortere array'et:
    entries: 50, //<---Dette er bare antallet af elementer vi ønsker i et array
    array: [],
}</code></pre>
                        <!-- <falsk kode der viser sortingObject kun med array, canvas og context>-->
                        Vi kan nu give dette sortingObject til drawArray:
                        <pre><code class='language-js'>function drawArray(sortingObject){ }</code></pre>
                        <!-- <falsk kode der bare viser sortingObject i parameter i drawArray>-->
                        Vi kan nu konstruere en funktion som tegner alle elementer i et array (Bemærk at vi har tilføjet en parameter 'selectedEntries', dette er for at vi eksempelvis visuelt kan markere hvis nogle elementer bliver sorteret ved at give dem en anden farve). 
                        <div class="code-snippet 73 100" id="Sorting/main"></div>
                        <!-- <kode>-->
                        Vi skal også definere funktionen der tegner et enkelt element:
                        <div class="code-snippet 50 72" id="Sorting/main"></div>
                        <!-- <kode>-->
                        <img class="figure" src="../../Files/tegn element.png"><br>
                        Denne figur skal illustrere hvordan canvas’ koordinatsystem har y-aksen der peger nedad. Dette betyder at vi skal være lidt mere kreative når vi tegner et element. Den røde linje viser hvor langt ud på x-aksen vi skal, og den grønne viser hvor langt ud på y-aksen vi skal før vi rammer elementet vi vil tegne (det orange). Dette er elementets start koordinat og findes ved at gå 'bredden af et element' $\cdot$ 'indekset af det nuværende element' ud af x-aksen og 'højde af lærred' $–$ 'højde af element' ud af y-aksen. <br>
                        Det antages at det største element i array’et vil være lige med antallet af elementer i array’et. Så for at gøre plads til dette element skriver vi 'højde af lærred'$\cdot \frac{array[i]}{array.length}$, bredden findes til at være $\frac{\text{'bredde af lærred'}}{array.length}$ da der skal være plads til $array.length$ elementer på lærredet.<br>
                        Yderligere ønsker vi at have en kant rundt om elementerne og yderligere plads mellem hvert element. Kanten kalder vi 'margin' og pladsen mellem hvert element hedder 'spaceBetweenElements'. For at gøre plads til dette forskyder vi (ud af x-aksen) alt med 'margin' og 'spaceBetweenElements'$/ 2$ (Vi tager det kvarte fra begge sider, så der i alt bliver 'spaceBetweenElements' plads på hver side af et element). Vi skal så derfor også gøre bredden af elementet mindre for at reflektere både 'margin' og 'spaceBetweenElements'. Så vi skriver
                        <div class="code-snippet 63 65" id="Sorting/main"></div>
                        <!-- <kode>-->
                        Og for højden skal vi kun tage forhold til 'margin' så højden af et element bliver:
                        <div class="code-snippet 58 61" id="Sorting/main"></div>
                        <!-- <kode>-->
                        Vi skal også forskyde (ud af y-aksen) med $-$'margin' og så er vi færdige, vi kan nu tegne et element.<br><br>
                        Vi kan nu lave funktioner der tegner et array hver gang et trin udføres i sorteringsalgoritmen, men hvad nu hvis en bruger starter to sorterings algoritmer på samme lærred på samme tid? Så får vi kaos, derfor skal vi i hver ’animations-tråd’ holde styr på om der er blevet startet en ny sortering. Løsningen kan findes ved at ændre i vores ’sortingObject’:
                        <div class="code-snippet 4 12" id="Sorting/main"></div>
                        <!-- <kode>-->
                        Nu vil vi, hver gang vi starter en animation sørge for at opdatere ’loopIndex’ og hele tiden sikre os at ’loopIndex’ er den der hører til vores animations-tråd. Vi kan starte med at lave en funktion der tegner alle elementer i array’et grønne. Vi kan spille denne animation når en sorteringsalgoritme er færdig:
                        <div class="code-snippet 108 128" id="Sorting/main"></div>
                        <!-- <kode>-->
                        </div>
                    </div>
                <h3>Tilfældige arrays</h3>
                Vi ønsker også at lave ikke-sorterede arrays, og det bedste sted at starte er med et sorteret array. Et sorteret array genereres på følgende måde:
                <div class="code-snippet 29 40" id="Sorting/main"></div>
                <!-- <kode>-->
                Dernæst bytter vi bare rundt på alle elementer så det ikke længere er sorteret:
                <div class="code-snippet 42 48" id="Sorting/main"></div>
                <!-- <kode>-->
                Hvor ’swap’ funktionen bare bytter to elementer i et array:
                <div class="code-snippet 22 27" id="Sorting/main"></div>
                <!-- <kode>-->
                Til sidst har vi et array der bliver tilfældigt genereret hver gang hjemmeside loades:
            </p>
            <figure>
                <canvas id="unsorted-canvas" width="300" height="300"></canvas>
            </figure>
        </div>
        
        <div class="page">
            <h2>Bubble Sort</h2>
            <h3>Hvad er Bubble Sort?</h3>
            <figure class="display bubbleSort"></figure>
            <p>
                Bubble Sort, på dansk Boble Sortering virker ved at sammenligne alle elementer i et array, $\mathbf A[i]$ med det næste element 
                i array'et, $\mathbf A[i+1]$. Siden målet for sådan en algoritme er at få de mindste elementer til venstre og de største til højre, 
                bytter vi de to elementer hvis  $\mathbf A[i] > \mathbf A[i+1]$, på den måde er de to elementer 'lokalt sorteret'. Når de to elementer er 
                blevet sorteret øger vi $i$ med 1 og gør det samme igen. Vi bliver ved indtil vi ikke kan længere - altså når $i+1$ er udenfor array'et.<br>
                Når vi har gjort dette vil det højeste element være rykket helt hen til højre i vores array - dette sker fordi, hvis $\mathbf A[i]$ er det største
                element i array'et, vil det naturligvis betyde at $\mathbf A[i] > \mathbf A[i+1]$, så derfor bytter vi disse to, og det der før var $\mathbf A[i]$ 
                er nu $\mathbf A[i + 1]$. Så når vi øger $i$ med 1 skal vi sammenligne det samme element (som jo var det største) og igen vil det være sandt at 
                $\mathbf A[i] > \mathbf A[i+1]$. Dette forsætter indtil det største element er helt til højre i array'et. (Det er derfor den hedder Bubble Sort
                - Fordi de største elementer flyder til toppen)
                <br>
                Bubble Sort gør brug af en 'Greedy Algorithm', på dansk en 'grådig algoritme', hvor man hele tiden tager lokalt optimale valg for at sortere array'et.
                Altså vi bytter rundt på to elementer hvis de er usorteret i forhold til hinanden.
                <br>
                Algoritmen's pseudokode er følgende:
<pre><code class='language-js'>function bubbleSort(array)
    i = 0
    WHILE( i < array.length )
        j = 0
        WHILE( j < array.length - 1 - i )
            IF( array[j] > array[j + 1] )
                SWAP( array[j] WITH array[j + 1] )
            j++
        i++
</code></pre><br>
            Skrevet i JavaScript, ser algoritmen sådan ud:
            <div class="code-snippet 2 10" id="Sorting/bubblesort"></div>
            <h3>Hvor god er Bubble Sort?</h3>
            Hvis $n$ er antallet af elementer i et usorteret array, kan vi udregne tidskompleksiteten for denne algoritme.
            Algoritmen indeholder 2 løkker, den ene går fra $i=0$ til $i= n - 1$ og den næste løkke fra $j=0$ til $j = n - 1 -i$. 
            Derfor er antallet af trin denne algoritme gennemgår:
            \[\sum_{k=0}^{n} \left(n-k\right)=\sum_{k=0}^{n} k=\frac{n(n+1)}{2}=\frac{n^2+n}{2}\]
            Tidskompleksiteten for denne algoritme er derfor $\frac{n^2+n}{2}$, men fordi vi kun er interesseret i hvordan kompleksiteten vokser
            og ikke hvor meget den vokser skriver man at tidskompleksiteten er $n^2+n$. Udover det er vi kun interesseret i det hurtigst voksende
            led, så vi ignorerer $n$ og skriver at tidskompleksiteten er $\mathcal O (n^2)$. <br>
            $\mathcal O(f(n))$ fortæller om 'worst-case' scenariet for algoritmen, hvor $\mathcal \Theta(f(n))$ er et gennemsnitligt scenarie
            og $\mathcal \Omega(f(n))$ er 'best-case'. Da tidskompleksiteten ikke ændrer sig uanset hvilket array der sorteres er denne algoritmes
            tidskompleksitet
            \[ \mathcal O(n^2)=\mathcal \Theta(n^2)=\mathcal \Omega(n^2) \]
            Rumkompleksiteten beskriver hvor meget ekstra plads en algoritme bruger, og da denne algoritme kun laver to variabler $i$ og $j$ og en ekstra 
            variabel hver gang vi bytter 2 elementer er dens rumkompleksitet $\mathcal O(1)$.
        </div>
        <div class="page">
            <h2>Insertion Sort</h2>
            <h3>Hvad er Insertion Sort?</h3>
            <figure class="display insertionSort"></figure>
            <p>
                Insertion Sort, på dansk Indsættelses Sortering, minder om Bubble Sort men har én stor forskel. Hvor Bubble Sort bytter to elementer
                hvis $\mathbf A[i] > \mathbf A[i+1]$, bliver Insertion Sort ved med at bytte indtil den ikke kan længere. Så altså hver gang 
                $\mathbf A[i] > \mathbf A[i+1]$ bliver de to elementer byttet og $i$ formindsket med 1.  Igen tjekkes det om $\mathbf A[i] > \mathbf A[i+1]$
                og der byttes hvis nødvendigt, når det ikke længere er tilfældet starter vi forfra og sætter $i$ 1 højere end den startede.
                <br>
                Algoritmen's pseudokode er følgende:
<pre><code class='language-js'>function insertionSort(array)
    i = 0
    WHILE( i < array.length - 1 )
        j = i
        WHILE( j > 0 AND array[j] > array[j + 1] )
            SWAP( array[j] WITH array[j + 1] )
            j--
        i++
</code></pre><br>
            Skrevet i JavaScript, ser algoritmen sådan ud:
            <div class="code-snippet 2 10" id="Sorting/insertionsort"></div>
            <h3>Hvor god er Insertion Sort?</h3>
            Tidskompleksiteten for denne algoritme er:<br>
            $\mathcal O(n^2) \quad \mathcal \Theta (n^2) \quad \mathcal \Omega(n)$<br>
            The bedste scenarie er når array'et allerede er sorteret, i dette tilfælde vil while-løkken aldrig køre og tidskompleksitet bliver $\mathcal \Omega(n)$.
            <br>
            The worst case occurs whenever the array is sorted backwards. In this case the while loop will keep running until $j=0$ for all values of $i$, 
            since it will always be the case that any element to the left will be larger than any element to the right. Repeating the calculations from 
            Bubble Sort we find a worst case of $\mathcal O(n^2)$. The derivation of the average case is a bit more involved, but the result is a time 
            complexity of $\Theta(n^2)$
            <div class="derivation">
                <input type="checkbox" name="derivation" id="insertionAverage">
                <label for="insertionAverage">Derivation of the average case</label>
                <div class="content">
                    Whenever we use Insertion Sort on an array, $\mathbf{A}$, everything to the left of the cursor $i$ will be sorted,
                    while everything on the right will be randomly arranged. For any entry $\mathbf{A}[i]$ that hasn't been sorted yet, 
                    it has $\frac{1}{i}$ probability of being larger than all elements to the left of $i$ 
                    (Meaning all elements: $\mathbf{A}[{j< i}]$). In fact, it has the same probability of being the second largest, third largest
                    and so on... This means the average element $\mathbf{A}[i]$ is the median of all elements to the left; $\mathbf{A}[{j< i}]$. 
                    Since all the elements, $\mathbf{A}[{j< i}]$, are sorted, the element $\mathbf{A}[i]$ must move $\frac i 2$ indices to the left.
                    This means we must, on average, perform $\frac i 2$ checks for each element in the array. So the total number of checks comes out to
                    \[\sum_{i=0}^{n-1}\frac{i}{2}=\frac{1}{2}\sum_{i=0}^{n-1}i=\frac{n(n-1)}{4}=\frac{n^2-n}{4}\]
                    Which means the average time complexity of the Insertion Sort algorithm is $\mathcal \Theta(n^2)$.
                    But notice that the number of checks are much better, compared to Bubble Sort, which has a constant $\frac{n^2+n}{2}$ number of checks per 
                    sort.
                </div>
            </div>
            Insertion Sort, like Bubble Sort, only creates a single variable when swapping two elements and when creating a for loop, 
            therefore the space complexity of Insertion Sort is $\mathcal O(1)$.
        </div>
        <div class="page">
            <h2>Merge Sort</h2>
            <h3>What is Merge Sort?</h3>
            <figure class="display mergeSort"></figure>
            Merge Sort uses the divide-and-conquer algorithm to sort an array.
            <img class="figure" src="../../Files/mergesort.png"><br>
            As seen from the picture above, the algorithm divides an array into two equally sized arrays (if possible). 
            It then recursively divides the new arrays into smaller arrays until the array only contains 1 element. 
            <div class="code-snippet 6 35" id="Sorting/mergesort"></div>
            When we reach the end of the dividing phase, we begin the
            next phase, the conquering. Moving backwards from the arrows in the picture we now have two sorted arrays that needs to be merged together.
            See that from the first step in this conquering phase, we have two arrays of size 1 we need to merge together (Since they only have 1 element we consider
            these arrays sorted). When merging we have two pointers, $l$ and $r$, one for each array ($\mathbf L$ and $\mathbf R$) we are merging. 
            We then check if$(\mathbf{L}[l]>\mathbf{R}[r])$ - if so we add $\mathbf{L}[l]$ to the combined array and increment $l$ by 1, if not we add 
            $\mathbf{R}[r]$ to the combined array and increment $r$ by 1.
            <div class="code-snippet 37 70" id="Sorting/mergesort"></div>
        </div>
        <div class="page">
            <h2>Joke sorts</h2>
            <h3>Stalin Sort</h3>
            <figure class="display stalinSort"></figure>
            Stalin Sort is very effective, with a time complexity of $\mathcal O(n)$, since it only ever compares each element to the largest 
            element before it. However, as you might notice, a lot of the data is lost. This is where the name comes from, every element not
            already sorted will be eliminated. On average the amount of information lost per sort is $(1-\log_2 \sqrt[n]{n})\cdot100\%$.
            The figure below shows how much information is lost as Stalin Sort is performed on more elements<br>
            <div class="derivation">
                <input type="checkbox" name="derivation" id="stalinLoss">
                <label for="stalinLoss">Derivation of the average loss</label>
                <div class="content">
                    (Assuming no array contains the same element twice)<br>
                    Each element in the array $\mathbf A_0$ will, on average, be the middle-most (or the median) value in the array. 
                    So after the first element, on average, $50\%$ of the array will be eliminated - since, on average, $50\%$ of the array
                    will be less than the first element. That leaves us with a new array, this array will have length $|\mathbf A_1| = 
                    \frac 1 2 |\mathbf A_0|$. Again, it will be true that the first element of $\mathbf A_1$ will, on average, be the median of 
                    $\mathbf A_1$ meaning we again eliminate $50\%$ of the array to create $\mathbf A_2$. This process keeps going until 
                    $|\mathbf A_N| = 1$. Each array $A_k$ will, on average, be half the size of the previous array $\mathbf A_{k-1}$, and we are
                    trying to find out when the size of the array is less than one. So we have an equation:
                    \begin{equation}
                    \begin{split}
                    \left(\frac{1}{2}\right)^N n = 1\\
                    \left(\frac{1}{2}\right)^N = \frac 1 n\\
                    \frac{1}{2^N} = \frac 1 n\\
                    2^N = n\\
                    N = \log_2 n
                    \end{split}
                    \end{equation}
                    This $\log_2 n$ is the number of elements the average Stalin Sort will leave you with. Meaning that $n-\log_2 n$ is the number
                    of elements you lose per sort. Rewriting as a fraction we get 
                    \[\frac {n-\log_2 n}n = 1-\frac {\log_2 n} n = 1-\log_2 n^{\frac{1}{n}} = 1-\log_2 \sqrt[n]n\]
                    And finally, rewriting as a percentage we get $(1-\log_2 \sqrt[n]{n})\cdot100\%$.
                </div>
            </div>
            <img class="figure" src="../../Files/stalin loss.png">
        </div>
    </div>
</body>
</html>
<script src="../pages.js"></script>
<script src="../prism.js"></script>
<script src="main.js"></script>
<script src="bubblesort.js"></script>
<script src="insertionsort.js"></script>
<script src="mergesort.js"></script>
<script src="stalinsort.js"></script>
<script src="../displayscripts.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>